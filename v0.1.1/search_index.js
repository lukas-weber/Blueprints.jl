var documenterSearchIndex = {"docs":
[{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [Blueprints]\nOrder = [:type, :function]","category":"page"},{"location":"api.html#Blueprints.Blueprint","page":"API","title":"Blueprints.Blueprint","text":"Blueprint\n\nA blueprint defined using B. Its positional and keyword arguments can be retrieved using getindex. The function can be accessed through its func field.\n\nExamples\n\njulia> blueprint = B(repeat, [1,2]; inner=100);\njulia> blueprint.func\nrepeat\njulia> blueprint[1]\n[1,2]\njulia> blueprint[:inner]\n100\n\nSee also: B, construct.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Blueprints.CachedBlueprint","page":"API","title":"Blueprints.CachedBlueprint","text":"CachedBlueprint\n\nA cached blueprint, defined using CachedB.\n\nFields\n\nfilename: the JLD2 file used as cache\ngroupname: the path of the object within the file.\nblueprint: the blueprint that is to be cached\n\n\n\n\n\n","category":"type"},{"location":"api.html#Blueprints.MapPolicy","page":"API","title":"Blueprints.MapPolicy","text":"MapPolicy(map_func)\n\nSimple parallel execution policy that allows specifying an implementation of parallel map. In this way, it is possible to construct blueprints either using threads or distributed workflows.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Blueprints.PhonyBlueprint","page":"API","title":"Blueprints.PhonyBlueprint","text":"Blueprints.PhonyBlueprint(constructor, dependencies, blueprint::Blueprint)\n\nLooks and serializes like blueprint, but actually executes constructor(dependencies).\n\nThis is useful mostly in cases where your calculation serializes in a very inefficient way or contains closures. In those cases, you can (at your own risk) mask the calculation behind a stand-in blueprint so that the result is still pure in terms of the arguments and parameters of blueprint.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Blueprints.B-Tuple{Any, Vararg{Any}}","page":"API","title":"Blueprints.B","text":"B(func, args...; params...)\n\nDefines a blueprint for the evaluation of func(args...; params...).\n\nnote: Note\nIt is important that the blueprinted function is pure: The function must not modify its inputs and its result must not depend on side effects. This is because construct will automatically apply memoization to avoid building the same blueprint more than once. Here, same is defined by isequal.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Blueprints.CachedB-Tuple{Tuple{AbstractString, AbstractString}, Any, Vararg{Any}}","page":"API","title":"Blueprints.CachedB","text":"CachedB(filename, func, args...; params...)\nCachedB((filename, groupname), func, args...; params...)\n\nDefines a cached blueprint for the evaluation of func(args...; params...).\n\nOn construct, the result is written to the JLD2 file called filename under the groupname groupname. If the cache already exists, it is loaded instead.\n\nIf groupname is omitted, a default group name is chosen using default_groupname.\n\nnote: Note\nUsing the default group name only works if all constituents of the blueprint have a repr that remains stable between Julia sessions. This is not true for closures.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Blueprints.CachedB-Tuple{Tuple{AbstractString, AbstractString}, Blueprint}","page":"API","title":"Blueprints.CachedB","text":"CachedB(filename, blueprint)\nCachedB((filename, groupname), blueprint)\n\nPromotes a regular blueprint into a cached blueprint.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Blueprints.construct-Tuple{Any}","page":"API","title":"Blueprints.construct","text":"construct(x; policy=MapPolicy(map), copy=true, readonly=false)\n\nIf x is a blueprint, constructs it.\nIf x is a cached blueprint, first tries to load from cache, otherwise writes the cache after construction.\nIf x implements Blueprints.dependencies, constructs its dependencies recursively and then x.\nElse, returns x.\n\nEach blueprint will only be constructed once. If another one which is identical (===) to it appears, the result is memoized.\n\npolicy can be used to set an execution policy for parallelization of independent calculations. At the moment, only MapPolicy is supported, which allows you to specify a parallel map implementation. In the future, additional policies may be implemented.\n\nIf copy is enabled, intermediate results will always be deepcopied before they are passed to constructors. This avoids unexpected data dependencies due to memoization, in cases like\n\na = B(zeros,4)\nresult = construct([a,a]; copy=false) # danger!\nresult[1][1] = 1\nresult\n\n# output\n2-element Vector{Any}:\n [1.0, 0.0, 0.0, 0.0]\n [1.0, 0.0, 0.0, 0.0]\n\nIf readonly is set, construction of cached blueprints will fail if their caches do not yet exist. In this mode, construct can be called from multiple processes without coordination on cached blueprints. ```\n\n\n\n\n\n","category":"method"},{"location":"api.html#Blueprints.default_groupname-Tuple{Any}","page":"API","title":"Blueprints.default_groupname","text":"Blueprints.default_groupname(x) -> String\n\nThe default groupname that is used by CachedB if only a filename is given. This will usually be a textual representation of the function call. If the representation is longer than Blueprints.MAX_CACHE_GROUPNAME_LENGTH, it is replaced by its hash instead.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Blueprints.dependencies","page":"API","title":"Blueprints.dependencies","text":"Blueprints.dependencies(x) -> (AbstractVector, Function)\n\nReturns the dependencies of x as a tuple of a vector deps and a constructor f so that f(deps) == x.\n\nDefining this method for a custom type allows to construct x transparently: If any of the dependencies are Blueprints, they will be recursively constructed before the whole type is. For example, constructing an array of blueprints will return an array of constructed blueprints.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Blueprints.jl","page":"Blueprints.jl","title":"Blueprints.jl","text":"","category":"section"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"Blueprints.jl implements thunks that are serializable, constructable in parallel using memoization and caching.","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"using Blueprints\n\nblueprint = B(+, 1, 2)\nresult = construct(blueprint)\n\n# output\n3","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"This makes them a useful building block for reproducible data workflows.","category":"page"},{"location":"index.html#Nesting","page":"Blueprints.jl","title":"Nesting","text":"","category":"section"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"Blueprints can be nested.","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"initialize_matrix(n,m; factor = 1) = factor * reshape(1:n*m, n, m)\n\na = B(initialize_matrix, 3, 3)\nb = B(initialize_matrix, 3, 1; factor = 1/2)\n\nblueprint = B(*, a, b)\nresult = construct(blueprint)","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"During construction intermediate results are automatically reused in construction if their blueprints are identical (as defined by ===).","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"function initialize_matrix(n,m; factor = 1)\n    println(\"call $n, $m\")\n    return factor * reshape(1:n*m, n, m)\nend\n\na = B(initialize_matrix, 3, 3)\nprintln(construct(B(+, a, a)))\n\n# but:\nb = B(initialize_matrix, 3, 3)\n@show a === b\nprintln(construct(B(+, a, b)))\n# output\n\ncall 3, 3\n[2 8 14; 4 10 16; 6 12 18]\na === b = false\ncall 3, 3\ncall 3, 3\n[2 8 14; 4 10 16; 6 12 18]","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"Nesting blueprints also works transparently with standard containers.","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"blueprint = B(sum, [a,a,a,b,b,b])\nconstruct(Dict(:a=>a, :r => blueprint))\n# output\ncall 3, 3\ncall 3, 3\nDict{Symbol, Matrix{Int64}} with 2 entries:\n  :a => [1 4 7; 2 5 8; 3 6 9]\n  :r => [6 24 42; 12 30 48; 18 36 54]","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"This can be extended to custom types by implementing Blueprints.dependencies.","category":"page"},{"location":"index.html#Serialization","page":"Blueprints.jl","title":"Serialization","text":"","category":"section"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"Blueprints can be serialized to JSON.","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"using Blueprints\nusing JSON\n\nblueprint = B(repeat, [1,2]; inner = 100)\nJSON.print(blueprint)\n\n# output\n\n{\"func\":\"repeat\",\"1\":[1,2],\"inner\":100}","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"This is much more compact and readable than having the actual 200-element array in JSON.","category":"page"},{"location":"index.html#Caching","page":"Blueprints.jl","title":"Caching","text":"","category":"section"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"To cache any (intermediate) result, all you have to do is to replace B by CachedB and specify a save location for a JLD2 cache file.","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"# cache_dir = ...\n\nx = CachedB(cache_dir * \"/cache.jld2\", initialize_matrix, 3,3)\ny = CachedB(cache_dir * \"/cache.jld2\", initialize_matrix, 3,1)\nresult = B(sum, B(*,x,y))\n\nprintln(construct(result))\nprintln(construct(result))\n# output\ncall 3, 3\ncall 3, 1\n108\n108","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"By default, results will be saved in the given file under a default group name based on the blueprint arguments (see Blueprints.default_groupname). To specify the group name manually, use","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"x = CachedB((cache_dir * \"/cache.jld2\", \"my_groupname\"), initialize_matrix, 3,3)\nconstruct(x)\n\nusing JLD2\ny = jldopen(cache_dir * \"/cache.jld2\", \"my_groupname\")\nx == y\n\n# output\ntrue","category":"page"},{"location":"index.html#Parallel-construction","page":"Blueprints.jl","title":"Parallel construction","text":"","category":"section"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"To parallelize the construction of heavy blueprints, you can pass an execution policy. For now, the only supported policy is MapPolicy, which lets you specify a parallel map implementation of your choice.","category":"page"},{"location":"index.html","page":"Blueprints.jl","title":"Blueprints.jl","text":"blueprint = B(sum, [a,a,a,b,b,b])\nconstruct(Dict(:a=>a, :r => blueprint); policy=MapPolicy(Threads.map))","category":"page"}]
}
